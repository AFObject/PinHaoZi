<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>手写笔记图像切割工具</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        @import url('https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap');
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f3f4f6;
        }
        #app {
            min-height: 100vh;
        }
        canvas {
            cursor: crosshair;
            box-shadow: 0 4px 6px -1px rgb(0 0 0 / 0.1), 0 2px 4px -2px rgb(0 0 0 / 0.1);
        }
    </style>
</head>
<body class="bg-gray-100 flex items-center justify-center p-4">
    <div id="app" class="bg-white rounded-lg shadow-xl p-8 max-w-4xl w-full flex flex-col gap-6">
        <h1 class="text-3xl font-bold text-gray-800 text-center">手写笔记图像切割工具</h1>
        
        <!-- 文件上传和控制面板 -->
        <div class="flex flex-col md:flex-row items-center justify-between gap-4 p-4 bg-gray-50 rounded-md">
            <label class="block text-sm font-medium text-gray-700">
                选择图片：
                <input type="file" id="imageLoader" class="mt-1 block w-full text-sm text-gray-500
                    file:mr-4 file:py-2 file:px-4
                    file:rounded-full file:border-0
                    file:text-sm file:font-semibold
                    file:bg-violet-50 file:text-violet-700
                    hover:file:bg-violet-100" />
            </label>
            <div class="flex items-center gap-4">
                <label class="flex flex-col text-sm font-medium text-gray-700">
                    横线数量：
                    <input type="number" id="lineCount" value="10" min="2" max="100" class="mt-1 w-20 rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                </label>
                <label class="flex flex-col text-sm font-medium text-gray-700">
                    垂直平移 (px)：
                    <input type="number" id="verticalOffsetInput" value="0" class="mt-1 w-20 rounded-md border-gray-300 shadow-sm focus:border-indigo-300 focus:ring focus:ring-indigo-200 focus:ring-opacity-50">
                </label>
            </div>
        </div>

        <!-- Canvas and Message Box -->
        <div class="relative w-full">
            <canvas id="imageCanvas" class="w-full h-auto rounded-lg bg-gray-200"></canvas>
            
            <!-- Custom modal for saving file -->
            <div id="saveModal" class="hidden absolute top-1/2 left-1/2 transform -translate-x-1/2 -translate-y-1/2 bg-white rounded-lg shadow-2xl p-6 z-10 border border-gray-200">
                <div class="flex flex-col gap-4">
                    <p class="text-gray-800 font-semibold">请输入文件名：</p>
                    <input type="text" id="fileNameInput" class="w-full p-2 border rounded-md focus:outline-none focus:ring-2 focus:ring-violet-500" placeholder="例如：我的笔记_第1行.png">
                    <div class="flex justify-end gap-2">
                        <button id="confirmSaveBtn" class="bg-violet-600 hover:bg-violet-700 text-white font-bold py-2 px-4 rounded-full transition-colors">确认</button>
                        <button id="cancelSaveBtn" class="bg-gray-300 hover:bg-gray-400 text-gray-800 font-bold py-2 px-4 rounded-full transition-colors">取消</button>
                    </div>
                </div>
            </div>
        </div>
        
        <div id="statusMessage" class="text-center text-sm text-gray-500 h-6">请载入图片并拖动鼠标进行选择</div>
        
    </div>

    <script>
        // 获取 HTML 元素
        const imageLoader = document.getElementById('imageLoader');
        const imageCanvas = document.getElementById('imageCanvas');
        const ctx = imageCanvas.getContext('2d');
        const lineCountInput = document.getElementById('lineCount');
        const verticalOffsetInput = document.getElementById('verticalOffsetInput');
        const statusMessage = document.getElementById('statusMessage');
        const saveModal = document.getElementById('saveModal');
        const fileNameInput = document.getElementById('fileNameInput');
        const confirmSaveBtn = document.getElementById('confirmSaveBtn');
        const cancelSaveBtn = document.getElementById('cancelSaveBtn');

        let originalImage = new Image();
        let imageLoaded = false;
        let scale = 1; // 图像在画布上的缩放比例
        let topBoundaryY = 0; // 上边界线的 Y 坐标 (在原始图像尺寸上的比例)
        let bottomBoundaryY = 1; // 下边界线的 Y 坐标 (在原始图像尺寸上的比例)
        let verticalOffset = 0; // 垂直平移的像素值
        let isDraggingTopBoundary = false;
        let isDraggingBottomBoundary = false;
        let isSelecting = false;
        let selectionStart = null;
        let selectionEnd = null;

        // 监听文件加载事件
        imageLoader.addEventListener('change', handleImage, false);
        lineCountInput.addEventListener('input', draw);
        verticalOffsetInput.addEventListener('input', function(e) {
            verticalOffset = parseInt(e.target.value, 10) || 0;
            draw();
        });

        function handleImage(e) {
            const reader = new FileReader();
            reader.onload = function(event) {
                originalImage.onload = function() {
                    imageLoaded = true;
                    // 设置画布尺寸以保持原始图像的宽高比
                    const containerWidth = imageCanvas.parentElement.clientWidth;
                    scale = containerWidth / originalImage.width;
                    imageCanvas.width = originalImage.width;
                    imageCanvas.height = originalImage.height;

                    // 调整 canvas 的 CSS 尺寸以适应容器
                    imageCanvas.style.width = containerWidth + 'px';
                    imageCanvas.style.height = (originalImage.height * scale) + 'px';

                    // 初始边界设置为整个图像
                    topBoundaryY = 0;
                    bottomBoundaryY = 1;
                    verticalOffset = 0;
                    verticalOffsetInput.value = 0;

                    draw();
                    statusMessage.textContent = '图片载入成功。你可以拖动红色边界线，或拖动鼠标选择行内区域。';
                };
                originalImage.src = event.target.result;
            };
            if (e.target.files[0]) {
                reader.readAsDataURL(e.target.files[0]);
            }
        }

        // 绘制所有内容的主函数
        function draw() {
            if (!imageLoaded) return;

            // 清空画布并绘制图像
            ctx.clearRect(0, 0, imageCanvas.width, imageCanvas.height);
            ctx.drawImage(originalImage, 0, 0);

            // 计算未平移的边界坐标
            const unshiftedTopY = topBoundaryY * imageCanvas.height;
            const unshiftedBottomY = bottomBoundaryY * imageCanvas.height;
            
            // 计算平移后的边界坐标，并确保它们在画布内
            const shiftedTopY = Math.max(0, Math.min(imageCanvas.height, unshiftedTopY + verticalOffset));
            const shiftedBottomY = Math.max(0, Math.min(imageCanvas.height, unshiftedBottomY + verticalOffset));
            const lineCount = parseInt(lineCountInput.value, 10);
            const lineSpacing = (unshiftedBottomY - unshiftedTopY) / (lineCount + 1);

            // 绘制上下边界线 (红色)
            ctx.strokeStyle = 'rgba(255, 0, 0, 0.7)';
            ctx.lineWidth = 4;
            ctx.beginPath();
            ctx.moveTo(0, shiftedTopY);
            ctx.lineTo(imageCanvas.width, shiftedTopY);
            ctx.moveTo(0, shiftedBottomY);
            ctx.lineTo(imageCanvas.width, shiftedBottomY);
            ctx.stroke();

            // 绘制中间的横线 (浅蓝色)
            ctx.strokeStyle = 'rgba(0, 150, 255, 0.5)';
            ctx.lineWidth = 1;
            for (let i = 1; i <= lineCount; i++) {
                const lineY = unshiftedTopY + i * lineSpacing + verticalOffset;
                // 确保中间的线也在画布内
                if (lineY >= 0 && lineY <= imageCanvas.height) {
                    ctx.beginPath();
                    ctx.moveTo(0, lineY);
                    ctx.lineTo(imageCanvas.width, lineY);
                    ctx.stroke();
                }
            }

            // 绘制选择区域 (绿色半透明)
            if (isSelecting && selectionStart && selectionEnd) {
                // 新逻辑：选择区域的垂直高度固定为所在行的高度，并考虑垂直平移
                const lineRelativeY = selectionStart.y - shiftedTopY;
                const lineIndex = Math.floor(lineRelativeY / lineSpacing);
                const lineTopY = unshiftedTopY + lineIndex * lineSpacing;
                
                const finalY = lineTopY + verticalOffset;
                const finalHeight = lineSpacing;
                
                const startX = Math.min(selectionStart.x, selectionEnd.x);
                const width = Math.abs(selectionStart.x - selectionEnd.x);

                ctx.fillStyle = 'rgba(0, 255, 0, 0.3)';
                ctx.fillRect(startX, finalY, width, finalHeight);

                ctx.strokeStyle = 'rgba(0, 255, 0, 0.7)';
                ctx.lineWidth = 2;
                ctx.strokeRect(startX, finalY, width, finalHeight);
            }
        }

        // 获取鼠标事件在画布上的坐标
        function getMousePos(canvas, event) {
            const rect = canvas.getBoundingClientRect();
            const x = (event.clientX - rect.left) / scale;
            const y = (event.clientY - rect.top) / scale;
            return { x, y };
        }

        imageCanvas.addEventListener('mousedown', function(e) {
            if (!imageLoaded) return;
            const pos = getMousePos(imageCanvas, e);
            
            // 检查是否正在拖动边界线，需要考虑垂直平移
            const shiftedTopY = topBoundaryY * imageCanvas.height + verticalOffset;
            const shiftedBottomY = bottomBoundaryY * imageCanvas.height + verticalOffset;

            if (Math.abs(pos.y - shiftedTopY) < 10) {
                isDraggingTopBoundary = true;
            } else if (Math.abs(pos.y - shiftedBottomY) < 10) {
                isDraggingBottomBoundary = true;
            } else {
                isSelecting = true;
                selectionStart = pos;
                selectionEnd = pos;
            }
        });

        imageCanvas.addEventListener('mousemove', function(e) {
            if (!imageLoaded) return;
            const pos = getMousePos(imageCanvas, e);

            if (isDraggingTopBoundary) {
                // 计算新的边界位置，并去除垂直平移的影响
                const newY = pos.y - verticalOffset;
                topBoundaryY = Math.max(0, Math.min(newY / imageCanvas.height, bottomBoundaryY));
                draw();
            } else if (isDraggingBottomBoundary) {
                // 计算新的边界位置，并去除垂直平移的影响
                const newY = pos.y - verticalOffset;
                bottomBoundaryY = Math.min(1, Math.max(newY / imageCanvas.height, topBoundaryY));
                draw();
            } else if (isSelecting) {
                selectionEnd = pos;
                draw();
            }
        });

        imageCanvas.addEventListener('mouseup', function(e) {
            if (!imageLoaded) return;

            if (isDraggingTopBoundary || isDraggingBottomBoundary) {
                isDraggingTopBoundary = false;
                isDraggingBottomBoundary = false;
            } else if (isSelecting && selectionStart && selectionEnd) {
                // 计算未平移的边界坐标
                const unshiftedTopY = topBoundaryY * imageCanvas.height;
                const unshiftedBottomY = bottomBoundaryY * imageCanvas.height;
                const lineCount = parseInt(lineCountInput.value, 10);
                const lineSpacing = (unshiftedBottomY - unshiftedTopY) / (lineCount + 1);
                
                // 确定是哪一行，需要将鼠标y坐标减去垂直平移量
                const shiftedTopY = unshiftedTopY + verticalOffset;
                const lineRelativeY = selectionStart.y - shiftedTopY;
                const lineIndex = Math.floor(lineRelativeY / lineSpacing);
                const cropRectY = unshiftedTopY + lineIndex * lineSpacing;
                
                // 裁剪区域的横向坐标由鼠标决定，纵向坐标由行决定
                const cropRect = {
                    x: Math.min(selectionStart.x, selectionEnd.x),
                    y: cropRectY,
                    width: Math.abs(selectionStart.x - selectionEnd.x),
                    height: lineSpacing
                };

                // 检查选区是否有效
                if (cropRect.width > 0 && cropRect.height > 0) {
                    showSaveModal(cropRect);
                }

                // 重置选择状态
                isSelecting = false;
                selectionStart = null;
                selectionEnd = null;
                draw(); // 重新绘制以清除选择框
            }
        });

        // 显示保存模态框
        function showSaveModal(cropRect) {
            saveModal.classList.remove('hidden');
            fileNameInput.focus();

            // 监听回车键事件，直接保存
            fileNameInput.onkeydown = function(e) {
                if (e.key === 'Enter') {
                    e.preventDefault(); // 阻止默认的表单提交行为
                    confirmSaveBtn.click();
                }
            };

            // 为确认按钮添加事件监听器
            confirmSaveBtn.onclick = function() {
                const fileName = fileNameInput.value || 'cropped_image';
                performCropAndSave(cropRect, fileName);
                saveModal.classList.add('hidden');
                fileNameInput.value = '';
            };

            // 为取消按钮添加事件监听器
            cancelSaveBtn.onclick = function() {
                saveModal.classList.add('hidden');
                fileNameInput.value = '';
            };
        }

        // 执行裁剪并下载
        function performCropAndSave(cropRect, fileName) {
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');
            tempCanvas.width = cropRect.width;
            tempCanvas.height = cropRect.height;
            tempCtx.drawImage(originalImage, cropRect.x, cropRect.y, cropRect.width, cropRect.height, 0, 0, cropRect.width, cropRect.height);

            const dataURL = tempCanvas.toDataURL('image/png');
            const link = document.createElement('a');
            link.href = dataURL;
            link.download = fileName + '.png';
            document.body.appendChild(link);
            link.click();
            document.body.removeChild(link);
            
            statusMessage.textContent = `已保存：${fileName}.png`;
        }
    </script>
</body>
</html>
